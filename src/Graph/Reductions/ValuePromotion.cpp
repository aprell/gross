#include "gross/Graph/Reductions/ValuePromotion.h"
#include "gross/Graph/NodeUtils.h"
#include <vector>

using namespace gross;
using namespace gross::graph_reduction;

// Replace value generated by SrcAssignStmt with value on RHS.
GraphReduction ValuePromotion::ReduceAssignment(Node* Assign) {
  NodeProperties<IrOpcode::SrcAssignStmt> NP(Assign);
  auto* DeadNode = NodeBuilder<IrOpcode::Dead>(&G).Build();
  // TODO: array access
  if(!NodeProperties<IrOpcode::SrcVarAccess>(NP.dest()))
    return NoChange();

  auto* SrcVal = NP.source();
  for(Node* Usr : Assign->effect_users()) {
    Usr->appendValueInput(SrcVal);
  }
  Assign->ReplaceWith(DeadNode, Use::K_EFFECT);

  return Replace(SrcVal);
}

// Replace value dep on SrcVarAccess(SrcArrayAccess) with
// value dep on the source value.
GraphReduction ValuePromotion::ReduceVarAccess(Node* VarAccess) {
  // wait until all inputs are visited
  for(auto* N : VarAccess->value_inputs()) {
    if(NodeMarker<ReductionState>::Get(N) != ReductionState::Visited)
      return Revisit(VarAccess);
  }

  if(VarAccess->getNumValueInput() > 1) {
    // one is the original decl the other is the
    // newly promoted value
    assert(VarAccess->getNumValueInput() == 2);
    auto* PromotedVal = VarAccess->getValueInput(1);
    VarAccess->ReplaceWith(PromotedVal, Use::K_VALUE);
    return Replace(PromotedVal);
  } else {
    return NoChange();
  }
}

GraphReduction ValuePromotion::Reduce(Node* N) {
  switch(N->getOp()) {
  case IrOpcode::SrcAssignStmt:
    return ReduceAssignment(N);
  case IrOpcode::SrcVarAccess:
    return ReduceVarAccess(N);
  default:
    return NoChange();
  }
}
