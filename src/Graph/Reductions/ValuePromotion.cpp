#include "gross/Graph/Reductions/ValuePromotion.h"
#include "gross/Graph/NodeUtils.h"
#include <vector>

using namespace gross;
using namespace gross::graph_reduction;

// Replace value generated by SrcAssignStmt with value on RHS.
GraphReduction ValuePromotion::ReduceAssignment(Node* Assign) {
  NodeProperties<IrOpcode::SrcAssignStmt> NP(Assign);
  assert(NP);
  auto* DeadNode = NodeBuilder<IrOpcode::Dead>(&G).Build();
  if(NodeProperties<IrOpcode::SrcArrayAccess>(NP.dest()))
    // array access hasn't been reduced to MemLoad
    return Revisit(Assign);
  if(NodeProperties<IrOpcode::MemLoad>(NP.dest()))
    return ReduceMemAssignment(Assign);
  if(!NodeProperties<IrOpcode::SrcVarAccess>(NP.dest()))
    return NoChange();

  auto* SrcVal = NP.source();
  for(Node* Usr : Assign->effect_users()) {
    switch(Usr->getOp()) {
    case IrOpcode::End:
    case IrOpcode::Start:
    case IrOpcode::IfTrue:
    case IrOpcode::IfFalse:
    case IrOpcode::Loop:
      // these ctrl nodes will not use the defined values
      continue;
    default:
      Usr->appendValueInput(SrcVal);
    }
  }
  Assign->Kill(DeadNode);

  return Replace(SrcVal);
}

GraphReduction ValuePromotion::ReduceMemAssignment(Node* Assign) {
  NodeProperties<IrOpcode::SrcAssignStmt> NP(Assign);
  assert(NP && NP.dest()->getOp() == IrOpcode::MemLoad);
  auto* DeadNode = NodeBuilder<IrOpcode::Dead>(&G).Build();

  // construction MemStore from MemLoad
  auto* MemLoadNode = NP.dest();
  NodeProperties<IrOpcode::MemLoad> LNP(MemLoadNode);
  auto* MemStoreNode = NodeBuilder<IrOpcode::MemStore>(&G)
                       .BaseAddr(LNP.BaseAddr())
                       .Offset(LNP.Offset())
                       .Src(NP.source())
                       .Build();
  // propagate side effects and control deps
  for(auto* E : MemLoadNode->effect_inputs())
    MemStoreNode->appendEffectInput(E);
  for(auto* C : MemLoadNode->control_inputs())
    MemStoreNode->appendControlInput(C);
  Assign->ReplaceWith(MemStoreNode, Use::K_EFFECT);
  Assign->Kill(DeadNode);
  return Replace(MemStoreNode);
}

// Replace value dep on SrcVarAccess(SrcArrayAccess) with
// value dep on the source value.
GraphReduction ValuePromotion::ReduceVarAccess(Node* VarAccess) {
  // wait until all inputs are visited
  for(auto* N : VarAccess->value_inputs()) {
    if(NodeMarker<ReductionState>::Get(N) != ReductionState::Visited)
      return Revisit(VarAccess);
  }

  if(VarAccess->getNumValueInput() > 1) {
    // one is the original decl the other is the
    // newly promoted value
    assert(VarAccess->getNumValueInput() == 2);
    auto* PromotedVal = VarAccess->getValueInput(1);
    VarAccess->ReplaceWith(PromotedVal, Use::K_VALUE);
    return Replace(PromotedVal);
  } else {
    return NoChange();
  }
}

// Reduce to MemLoad first, then transform to MemStore if needed
GraphReduction ValuePromotion::ReduceMemAccess(Node* MemAccess) {
  NodeProperties<IrOpcode::SrcArrayAccess> NP(MemAccess);
  assert(NP);

  // wait until all inputs are visited
  for(auto* N : MemAccess->value_inputs()) {
    if(NodeMarker<ReductionState>::Get(N) != ReductionState::Visited)
      return Revisit(MemAccess);
  }

  Node* ArrayDecl = NP.decl();
  NodeProperties<IrOpcode::SrcArrayDecl> DNP(ArrayDecl);
  assert(DNP);
  auto DimSize = NP.dim_size(),
       DeclDimSize = DNP.dim_size();
  assert(DimSize == DeclDimSize && DimSize > 0);
  std::vector<Node*> Accums;
  for(auto I = 0U, DI = 0U; I < DimSize - 1 && DI < DeclDimSize - 1;
      ++I, ++DI) {
    auto* M = NodeBuilder<IrOpcode::BinMul>(&G)
              .LHS(NP.dim(I)).RHS(DNP.dim(DI))
              .Build();
    Accums.push_back(M);
  }
  Accums.push_back(NP.dim(DimSize - 1));

  auto IA = Accums.begin();
  auto* OffsetNode = *IA;
  ++IA;
  for(auto EA = Accums.end(); IA != EA; ++IA) {
    OffsetNode = NodeBuilder<IrOpcode::BinAdd>(&G)
                 .LHS(OffsetNode).RHS(*IA)
                 .Build();
  }
  auto* MemLoadNode = NodeBuilder<IrOpcode::MemLoad>(&G)
                      .BaseAddr(ArrayDecl).Offset(OffsetNode)
                      .Build();

  // propagate side effects and control deps
  for(auto* E : MemAccess->effect_inputs())
    MemLoadNode->appendEffectInput(E);
  for(auto* C : MemAccess->control_inputs())
    MemLoadNode->appendControlInput(C);
  MemAccess->ReplaceWith(MemLoadNode, Use::K_VALUE);
  return Replace(MemLoadNode);
}

GraphReduction ValuePromotion::Reduce(Node* N) {
  switch(N->getOp()) {
  case IrOpcode::SrcAssignStmt:
    return ReduceAssignment(N);
  case IrOpcode::SrcVarAccess:
    return ReduceVarAccess(N);
  case IrOpcode::SrcArrayAccess:
    return ReduceMemAccess(N);
  default:
    return NoChange();
  }
}
